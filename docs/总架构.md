

开发阶段：使用 PyCharm 和 WebStorm，享受它们为特定语言和框架提供的深度优化和强大的重构工具。

联调与部署阶段：切换到 VS Code，使用一个 launch.json 文件统一管理所有服务，这让环境配置变得可移植、可复现，非常适合团队协作和后续的自动化部署流程。

好的，我帮你把这些零散的构想整理成一个比较完整、结构清晰的 **需求文档 + 数据库设计方案**，你可以直接给到 Cursor 去逐步实现。

---

# 📘 ChatBox 项目需求文档

## 1. 项目目标

构建一个 **轻量级的仿 ChatGPT 聊天应用**，支持多用户、多会话，支持流式输出与 Markdown 渲染。
后端基于 **FastAPI + MySQL**，前端基于 **Vue3**。

---

## 2. 核心功能需求

### 2.1 基础功能

* 用户注册 / 登录（用户名 + 密码，密码需加密存储）。
* 用户可发起新的对话。
* 对话中支持多轮交互，一问一答。
* AI 大模型接口已提供（函数调用 + 流式输出）。大模型还可以有联网搜索、深度思考开关的选项

### 2.2 对话管理

* 每个用户可以有多个会话。
* 会话标题由大模型在第一轮对话后自动生成。
* 支持加载历史会话，点击会话标题后可以恢复并继续对话。
* 会话与消息均需存储在数据库。

### 2.3 消息流式输出

* 前端实时接收并渲染大模型输出。
* 消息支持 **Markdown 渲染**。

### 2.4 历史记录功能

* 查询某用户的所有会话列表（按 `updated_at` 倒序）。
* 加载某个会话的完整消息历史（按 `created_at` 顺序）。
* 支持“重新加载”功能，即断线后能恢复之前的会话。

### 2.5 加分项

* 历史会话标题自动生成。
* 用户体验优化：支持滚动加载消息、分页等。

---

## 3. 技术栈

* **前端**: Vue3 (简洁页面，支持流式渲染 + Markdown)。
* **后端**: FastAPI。
* **数据库**: MySQL。

  * host: `localhost`
  * port: `3306`
  * user: `root`
  * password: `305857`
* **鉴权**: JWT (基于用户名 + 密码登录)。

---

## 4. 数据库表结构设计

### 4.1 用户表 `users`

存储用户账号信息。

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    hashed_password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

---

### 4.2 会话表 `conversations`

存储每个用户的独立会话。

```sql
CREATE TABLE conversations (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    title VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

* **说明**：`title` 初始可设为 `"新对话"`，在第一轮问答后更新为大模型生成的标题。

---

### 4.3 消息表 `messages`

存储每一轮对话的具体消息。

```sql
CREATE TABLE messages (
    id INT AUTO_INCREMENT PRIMARY KEY,
    conversation_id INT NOT NULL,
    role ENUM('user', 'assistant') NOT NULL,
    content TEXT NOT NULL,
    status ENUM('processing', 'completed', 'failed') DEFAULT 'completed',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_conversation FOREIGN KEY(conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
);
```

* **说明**：

  * `role` 区分消息是 **用户** 还是 **AI**。
  * `status` 允许支持流式输出过程中的中间态。

---

## 5. 数据流与交互流程

### 5.1 用户登录

1. 用户输入 `username` + `password`。
2. 后端验证并返回 JWT Token。
3. 前端将 Token 存储，后续请求需携带 Token。

---

### 5.2 新建对话

1. 用户发送第一条消息。
2. 后端：

   * 在 `conversations` 中插入一条新记录，`title = "新对话"`。
   * 在 `messages` 中插入该条消息，`role='user'`。
   * 调用大模型 API，先在 `messages` 插入一条 `role='assistant'` 且 `status='processing'` 的记录。
   * 模型返回后更新 `content` 与 `status='completed'`。
   * 调用大模型生成标题，并更新 `conversations.title`。

---

### 5.3 继续对话

1. 用户在已有会话中继续提问。
2. 后端仅在 `messages` 表中追加记录（`role='user'` + `role='assistant'`）。
3. 更新该会话的 `updated_at` 字段。

---

### 5.4 历史会话加载

1. 用户进入历史会话列表。
2. 后端查询 `conversations`（按 `updated_at` 降序）。
3. 用户点击某个会话，后端加载该 `conversation_id` 下的所有 `messages`（按 `created_at` 升序）。
4. 前端渲染完整对话。

---

## 6. 目录结构建议

```
chatbox/
│── backend/
│   ├── main.py             # FastAPI 入口
│   ├── database.py         # 数据库连接 & ORM
│   ├── models.py           # SQLAlchemy ORM 模型
│   ├── schemas.py          # Pydantic 模型
│   ├── auth.py             # 登录 & JWT 验证
│   ├── services/
│   │   ├── llm_service.py  # 大模型调用（流式输出）
│   │   └── auth_service.py # 用户认证逻辑
│   └── routers/
│       ├── users.py        # 用户相关接口
│       ├── conversations.py# 会话相关接口
│       └── messages.py     # 消息相关接口
│
│── frontend/
│   ├── index.html          # 入口页面
│   └── src/
│       ├── main.js         # Vue3 入口
│       ├── api/            # 与后端交互
│       └── components/     # UI 组件 (ChatBox, LoginForm...)
```



